'use strict';
var vscode = require('vscode');
var path = require('path');
var fs = require('fs');
var url = require('url');
var os = require('os');
var INSTALL_CHECK = false;
const debugLogger = require('./src/debugLogger');
const { resolveSettingPath } = require('./src/pathResolver');
const { resolveStylesheetHref } = require('./src/stylesheetResolver');
const cacheManager = require('./src/cacheManager');

// MarkPrint Phase 1: Template Foundations
const TemplateRegistry = require('./src/templateRegistry');
const StatusBarManager = require('./src/statusBar');
const SchemaValidator = require('./src/schemaValidator');
const packageJson = require('./package.json');

// MarkPrint Phase 2: Renderer Abstraction
const { RendererRegistry } = require('./src/renderers/index');
const ChromiumRenderer = require('./src/renderers/chromiumRenderer');

const EXTENSION_DISPLAY_NAME =
  (packageJson && (packageJson.displayName || packageJson.name)) ||
  'MarkPrint';

// Global instances
let templateRegistry;
let statusBarManager;
let schemaValidator;
let rendererRegistry;
let extensionContext;
const deprecatedSettingWarnings = new Set();

function warnIfDeprecatedSettingUsed(settingKey, guidance) {
  try {
    const config = vscode.workspace.getConfiguration('markprint');
    const inspected = config.inspect(settingKey);
    if (!inspected) {
      return;
    }
    const hasOverride =
      inspected.workspaceFolderValue !== undefined ||
      inspected.workspaceValue !== undefined ||
      inspected.globalValue !== undefined;
    if (hasOverride && !deprecatedSettingWarnings.has(settingKey)) {
      const message = `markprint.${settingKey} is deprecated. ${guidance}`;
      vscode.window.showWarningMessage(message);
      debugLogger.log('settings', message);
      deprecatedSettingWarnings.add(settingKey);
    }
  } catch (error) {
    debugLogger.log('warn', 'Failed to check deprecated setting', { settingKey, error: error.message });
  }
}

function activate(context) {
  extensionContext = context;
  process.env.MARKPRINT_EXTENSION_PATH = context.extensionPath;
  init();

  // Initialize Phase 1 components
  templateRegistry = new TemplateRegistry(context);
  templateRegistry.setFallbackSelector(payload => handleTemplateFallback(payload));
  statusBarManager = new StatusBarManager();
  schemaValidator = new SchemaValidator();

  // Initialize Phase 2: Renderer abstraction
  rendererRegistry = new RendererRegistry();
  rendererRegistry.register('chromium', new ChromiumRenderer({
    extensionPath: context.extensionPath
  }));

  debugLogger.log('renderer', 'Renderer registry initialized', {
    available: rendererRegistry.getNames(),
    default: rendererRegistry.defaultRenderer
  });

  // Initialize template registry
  templateRegistry.initialize().catch(err => {
    debugLogger.log('error', 'Failed to initialize template registry', { error: err.message, stack: err.stack });
  });

  // Initialize status bar
  statusBarManager.initialize();
  context.subscriptions.push(statusBarManager);

  // Register Phase 1 commands
  context.subscriptions.push(
    vscode.commands.registerCommand('markprint.changeBuildMode', async function () {
      await statusBarManager.showBuildModePicker();
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand('markprint.selectTemplate', async function () {
      const editor = vscode.window.activeTextEditor;
      if (!editor) return;
      await templateRegistry.promptTemplateSelection(editor.document, context.workspaceState);
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand('markprint.reloadTemplates', async function () {
      await templateRegistry.reload();
      vscode.window.showInformationMessage('Templates reloaded');
    })
  );

  context.subscriptions.push(
    vscode.commands.registerCommand('markprint.clearCache', function () {
      cacheManager.clearAll();
      vscode.window.showInformationMessage('MarkPrint cache cleared');
    })
  );

  // Existing commands
  var commands = [
    vscode.commands.registerCommand('extension.markprint.settings', async function () { await markprint('settings', context); }),
    vscode.commands.registerCommand('extension.markprint.pdf', async function () { await markprint('pdf', context); }),
    vscode.commands.registerCommand('extension.markprint.html', async function () { await markprint('html', context); }),
    vscode.commands.registerCommand('extension.markprint.png', async function () { await markprint('png', context); }),
    vscode.commands.registerCommand('extension.markprint.jpeg', async function () { await markprint('jpeg', context); }),
    vscode.commands.registerCommand('extension.markprint.all', async function () { await markprint('all', context); })
  ];
  commands.forEach(function (command) {
    context.subscriptions.push(command);
  });

  // Handle build modes
  var buildMode = vscode.workspace.getConfiguration('markprint')['buildMode'] || 'manual';
  var isConvertOnSave = vscode.workspace.getConfiguration('markprint')['convertOnSave'];
  warnIfDeprecatedSettingUsed('convertOnSave', 'Use markprint.buildMode set to "auto" or "hybrid" instead.');

  // Legacy convertOnSave or auto mode
  if (isConvertOnSave || buildMode === 'auto') {
    var disposable_onsave = vscode.workspace.onDidSaveTextDocument(async function (doc) {
      await markdownPdfOnSave(doc, context);
    });
    context.subscriptions.push(disposable_onsave);
  }

  // Hybrid mode: lightweight preview on save
  if (buildMode === 'hybrid') {
    var disposable_hybrid = vscode.workspace.onDidSaveTextDocument(async function (doc) {
      if (doc.languageId === 'markdown') {
        await validateAndPreview(doc, context);
      }
    });
    context.subscriptions.push(disposable_hybrid);
  }

  // Update status bar on active editor change
  context.subscriptions.push(
    vscode.window.onDidChangeActiveTextEditor(async function (editor) {
      if (editor && editor.document.languageId === 'markdown') {
        const template = await templateRegistry.getTemplateForDocument(editor.document, context.workspaceState);
        if (template) {
          statusBarManager.setTemplate(template);
        }
      } else {
        statusBarManager.clearTemplate();
      }
    })
  );

  // Update status bar on config change
  context.subscriptions.push(
    vscode.workspace.onDidChangeConfiguration(e => {
      if (e.affectsConfiguration('markprint.buildMode')) {
        statusBarManager.updateBuildMode();
      }
    })
  );

  context.subscriptions.push(schemaValidator);
}
exports.activate = activate;

// this method is called when your extension is deactivated
function deactivate() {
}
exports.deactivate = deactivate;

// Phase 1: Validate and preview (hybrid mode)
async function validateAndPreview(document, context) {
  try {
    // Get template for document
    const template = await templateRegistry.getTemplateForDocument(document, context.workspaceState);
    if (!template) {
      return; // No template selected, skip validation
    }

    // Validate metadata
    const isValid = await schemaValidator.validateDocument(document, template);
    if (!isValid) {
      // Validation errors reported to Problems panel, don't proceed
      return;
    }

    // Clear any previous validation errors
    schemaValidator.clearDiagnostics(document);

    // Show lightweight HTML preview (future: could generate HTML preview)
    vscode.window.setStatusBarMessage('$(check) Template validation passed', 3000);
  } catch (error) {
    debugLogger.log('error', 'Validation and preview failed', { error: error.message });
  }
}

async function markprint(option_type, context) {

  try {

    // check active window
    var editor = vscode.window.activeTextEditor;
    if (!editor) {
      vscode.window.showWarningMessage('No active Editor!');
      return;
    }

    // check markdown mode
    var mode = editor.document.languageId;
    if (mode != 'markdown') {
      vscode.window.showWarningMessage('It is not a markdown mode!');
      return;
    }

    var uri = editor.document.uri;
    var mdfilename = uri.fsPath;
    var ext = path.extname(mdfilename);
    if (!isExistsPath(mdfilename)) {
      if (editor.document.isUntitled) {
        vscode.window.showWarningMessage('Please save the file!');
        return;
      }
      vscode.window.showWarningMessage('File name does not get!');
      return;
    }

    let activeTemplate = null;

    // Phase 1: Validate template if available
    if (context && templateRegistry && schemaValidator) {
      activeTemplate = await templateRegistry.getTemplateForDocument(editor.document, context.workspaceState);
      const template = activeTemplate;
      if (template) {
        const rendererInfo = template.renderer || { engine: 'chromium' };
        const rendererEngine = rendererInfo.engine || 'chromium';
        if (rendererEngine !== 'chromium') {
          debugLogger.log('renderer', 'Renderer hint not yet supported. Continuing with Chromium export.', {
            document: editor.document.uri.fsPath,
            requestedEngine: rendererEngine,
            templateId: template.id
          });
        } else {
          debugLogger.log('renderer', 'Using Chromium renderer for export', {
            document: editor.document.uri.fsPath,
            templateId: template.id
          });
        }

        const layoutHint =
          template.layoutRendererHint ||
          (template.layoutDescriptor && template.layoutDescriptor.rendererHint) ||
          null;
        if (layoutHint && layoutHint !== 'chromium') {
          debugLogger.log('renderer', 'Layout requested alternate renderer', {
            document: editor.document.uri.fsPath,
            templateId: template.id,
            layoutHint
          });
        }

        const isValid = await schemaValidator.validateDocument(editor.document, template);
        if (!isValid) {
          vscode.window.showErrorMessage('Export blocked: template validation failed. Check Problems panel.');
          return;
        }
        schemaValidator.clearDiagnostics(editor.document);
      }
    }

    var types_format = ['html', 'pdf', 'png', 'jpeg'];
    var filename = '';
    var types = [];
    if (types_format.indexOf(option_type) >= 0) {
      types[0] = option_type;
    } else if (option_type === 'settings') {
      var types_tmp = vscode.workspace.getConfiguration('markprint')['type'] || 'pdf';
      if (types_tmp && !Array.isArray(types_tmp)) {
          types[0] = types_tmp;
      } else {
        types = vscode.workspace.getConfiguration('markprint')['type'] || 'pdf';
      }
    } else if (option_type === 'all') {
      types = types_format;
    } else {
      showErrorMessage('markprint().1 Supported formats: html, pdf, png, jpeg.');
      return;
    }

    // convert and export markdown to pdf, html, png, jpeg
    if (types && Array.isArray(types) && types.length > 0) {
      const documentText = editor.document.getText();

      // Build render context for renderer selection
      const renderContext = {
        format: types[0], // Will be updated per type in loop
        template: activeTemplate,
        layout: activeTemplate ? activeTemplate.layoutDescriptor : null,
        document: mdfilename
      };

      // Select renderer based on context
      const renderer = rendererRegistry.select(renderContext);
      if (!renderer) {
        throw new Error('No suitable renderer available for requested format');
      }

      debugLogger.log('renderer', 'Selected renderer', {
        name: renderer.name,
        version: renderer.version,
        formats: types,
        template: activeTemplate ? activeTemplate.id : 'none',
        layoutHint: renderContext.layout ? renderContext.layout.rendererHint : 'none'
      });

      for (var i = 0; i < types.length; i++) {
        var type = types[i];
        if (types_format.indexOf(type) >= 0) {
          filename = mdfilename.replace(ext, '.' + type);
          renderContext.format = type; // Update format for this iteration

          await renderWithEngine({
            renderer,
            type,
            uri,
            text: documentText,
            filename,
            sourcePath: mdfilename,
            template: activeTemplate,
            context: renderContext
          });
        } else {
          showErrorMessage('markprint().2 Supported formats: html, pdf, png, jpeg.');
          return;
        }
      }
    } else {
      showErrorMessage('markprint().3 Supported formats: html, pdf, png, jpeg.');
      return;
    }
  } catch (error) {
    if (!error || !error.__markprintLogged) {
      showErrorMessage('markprint()', error);
    } else {
      debugLogger.log('error', 'markprint() error', { error: error && error.message ? error.message : error });
    }
  }
}

/**
 * Render pipeline using selected renderer (Phase 2)
 * @param {Object} params - Render parameters
 * @param {IRendererDriver} params.renderer - Selected renderer instance
 * @param {string} params.type - Output format (pdf, html, png, jpeg)
 * @param {Object} params.uri - VS Code URI
 * @param {string} params.text - Markdown source text
 * @param {string} params.filename - Output filename
 * @param {string} params.sourcePath - Source file path
 * @param {Object} params.template - Active template metadata
 * @param {Object} params.context - Rendering context
 */
async function renderWithEngine({ renderer, type, uri, text, filename, sourcePath, template, context }) {
  debugLogger.log('renderer', 'Render pipeline start', {
    renderer: renderer.name,
    type,
    document: sourcePath
  });

  // Parse front matter
  const grayMatter = require('gray-matter');
  const matterParts = grayMatter(text);

  // Markdown → HTML
  const content = convertMarkdownToHtml(sourcePath, type, text, { matterParts });

  // HTML + template → final HTML
  const html = makeHtml(content, uri, {
    template,
    frontMatter: matterParts ? matterParts.data : null
  });

  if (typeof html !== 'string' || html.length === 0) {
    throw new Error('Renderer produced empty HTML content.');
  }

  // Resolve output directory (profile → setting → source directory)
  const outputDir = resolveOutputDirectory(sourcePath, template);
  const outputPath = path.join(outputDir, path.basename(filename));

  // Build render options
  const renderOptions = {
    path: outputPath,
    format: type,
    uri,
    template,
    frontMatter: matterParts.data,
    context
  };

  // Dispatch to renderer based on type
  switch (type) {
    case 'pdf':
      await renderer.renderToPdf(html, renderOptions);
      break;
    case 'html':
      await renderer.renderToHtml(html, renderOptions);
      break;
    case 'png':
      await renderer.renderToPng(html, renderOptions);
      break;
    case 'jpeg':
      await renderer.renderToJpeg(html, renderOptions);
      break;
    default:
      throw new Error('Unsupported format: ' + type);
  }

  debugLogger.log('renderer', 'Render pipeline complete', {
    renderer: renderer.name,
    output: outputPath
  });

  // Show completion message (replicate existing behavior)
  const StatusbarMessageTimeout = vscode.workspace.getConfiguration('markprint')['StatusbarMessageTimeout'];
  vscode.window.setStatusBarMessage('$(markdown) ' + outputPath, StatusbarMessageTimeout);
}

/**
 * Resolve output directory with precedence: profile → setting → default
 * @param {string} sourcePath - Source markdown file path
 * @param {Object} template - Active template with profile
 * @returns {string} Resolved output directory path
 */
function resolveOutputDirectory(sourcePath, template) {
  // Priority 1: Profile output directory
  if (template && template.profile && template.profile.outputs) {
    const outputConfig = template.profile.outputs.pdf || template.profile.outputs.html;
    if (outputConfig && outputConfig.target_directory) {
      debugLogger.log('renderer', 'Using profile output directory', {
        directory: outputConfig.target_directory,
        precedence: 'profile'
      });
      return resolveSettingPath(outputConfig.target_directory, vscode.Uri.file(sourcePath));
    }
  }

  // Priority 2: markprint.outputDirectory setting
  const settingDir = vscode.workspace.getConfiguration('markprint')['outputDirectory'];
  if (settingDir) {
    debugLogger.log('renderer', 'Using setting output directory', {
      directory: settingDir,
      precedence: 'setting'
    });
    return getOutputDir(sourcePath, vscode.Uri.file(sourcePath));
  }

  // Priority 3: Same directory as source file
  debugLogger.log('renderer', 'Using source directory', {
    directory: path.dirname(sourcePath),
    precedence: 'default'
  });
  return path.dirname(sourcePath);
}

async function markdownPdfOnSave(doc, context) {
  try {
    if (!doc || doc.languageId !== 'markdown') {
      return;
    }
    if (!isMarkdownPdfOnSaveExclude(doc)) {
      await markprint('settings', context);
    }
  } catch (error) {
    showErrorMessage('markdownPdfOnSave()', error);
  }
}

function isMarkdownPdfOnSaveExclude(doc) {
  try {
    const target = doc || vscode.window.activeTextEditor && vscode.window.activeTextEditor.document;
    if (!target) {
      return false;
    }
    const filename = path.basename(target.fileName);
    var patterns = vscode.workspace.getConfiguration('markprint')['convertOnSaveExclude'] || '';
    var pattern;
    var i;
    if (patterns && Array.isArray(patterns) && patterns.length > 0) {
      for (i = 0; i < patterns.length; i++) {
        pattern = patterns[i];
        var re = new RegExp(pattern);
        if (re.test(filename)) {
          return true;
        }
      }
    }
    return false;
  } catch (error) {
    showErrorMessage('isMarkdownPdfOnSaveExclude()', error);
  }
}

/*
 * convert markdown to html (markdown-it)
 */
function convertMarkdownToHtml(filename, type, text, options = {}) {
  var grayMatter = require("gray-matter");
  var matterParts = options && options.matterParts ? options.matterParts : grayMatter(text);

  try {
    try {
      var statusbarmessage = vscode.window.setStatusBarMessage('$(markdown) Converting (convertMarkdownToHtml) ...');
      var hljs = require('highlight.js');
      var breaks = setBooleanValue(matterParts.data.breaks, vscode.workspace.getConfiguration('markprint')['breaks']);
      var md = require('markdown-it')({
        html: true,
        breaks: breaks,
        highlight: function (str, lang) {

          if (lang && lang.match(/\bmermaid\b/i)) {
            return `<div class="mermaid">${str}</div>`;
          }

          if (lang && hljs.getLanguage(lang)) {
            try {
              str = hljs.highlight(lang, str, true).value;
            } catch (error) {
              str = md.utils.escapeHtml(str);

              showErrorMessage('markdown-it:highlight', error);
            }
          } else {
            str = md.utils.escapeHtml(str);
          }
          return '<pre class="hljs"><code><div>' + str + '</div></code></pre>';
        }
      });
    } catch (error) {
      statusbarmessage.dispose();
      showErrorMessage('require(\'markdown-it\')', error);
    }

  // convert the img src of the markdown
  var cheerio = require('cheerio');
  var defaultRender = md.renderer.rules.image;
  md.renderer.rules.image = function (tokens, idx, options, env, self) {
    var token = tokens[idx];
    var href = token.attrs[token.attrIndex('src')][1];
    // console.log("original href: " + href);
    if (type === 'html') {
      href = decodeURIComponent(href).replace(/("|')/g, '');
    } else {
      href = convertImgPath(href, filename);
    }
    // console.log("converted href: " + href);
    token.attrs[token.attrIndex('src')][1] = href;
    // // pass token to default renderer.
    return defaultRender(tokens, idx, options, env, self);
  };

  if (type !== 'html') {
    // convert the img src of the html
    md.renderer.rules.html_block = function (tokens, idx) {
      var html = tokens[idx].content;
      var $ = cheerio.load(html);
      $('img').each(function () {
        var src = $(this).attr('src');
        var href = convertImgPath(src, filename);
        $(this).attr('src', href);
      });
      return $.html();
    };
  }

  // checkbox
  md.use(require('markdown-it-checkbox'));

  // emoji
  var emoji_f = setBooleanValue(matterParts.data.emoji, vscode.workspace.getConfiguration('markprint')['emoji']);
  if (emoji_f) {
    var emojies_defs = require(path.join(__dirname, 'data', 'emoji.json'));
    try {
      var options = {
        defs: emojies_defs
      };
    } catch (error) {
      statusbarmessage.dispose();
      showErrorMessage('markdown-it-emoji:options', error);
    }
    md.use(require('markdown-it-emoji'), options);
    md.renderer.rules.emoji = function (token, idx) {
      var emoji = token[idx].markup;
      var emojipath = path.join(__dirname, 'node_modules', 'emoji-images', 'pngs', emoji + '.png');
      var emojidata = readFile(emojipath, null).toString('base64');
      if (emojidata) {
        return '<img class="emoji" alt="' + emoji + '" src="data:image/png;base64,' + emojidata + '" />';
      } else {
        return ':' + emoji + ':';
      }
    };
  }

  // toc
  // https://github.com/leff/markdown-it-named-headers
  var options = {
    slugify: Slug
  }
  md.use(require('markdown-it-named-headers'), options);

  // markdown-it-container
  // https://github.com/markdown-it/markdown-it-container
  md.use(require('markdown-it-container'), '', {
    validate: function (name) {
      return name.trim().length;
    },
    render: function (tokens, idx) {
      if (tokens[idx].info.trim() !== '') {
        return `<div class="${tokens[idx].info.trim()}">\n`;
      } else {
        return `</div>\n`;
      }
    }
  });

  // PlantUML
  // https://github.com/gmunguia/markdown-it-plantuml
  var plantumlOptions = {
    openMarker: matterParts.data.plantumlOpenMarker || vscode.workspace.getConfiguration('markprint')['plantumlOpenMarker'] || '@startuml',
    closeMarker: matterParts.data.plantumlCloseMarker || vscode.workspace.getConfiguration('markprint')['plantumlCloseMarker'] || '@enduml',
    server: vscode.workspace.getConfiguration('markprint')['plantumlServer'] || ''
  }
  md.use(require('markdown-it-plantuml'), plantumlOptions);

  // markdown-it-include
  // https://github.com/camelaissani/markdown-it-include
  // the syntax is :[alt-text](relative-path-to-file.md)
  // https://talk.commonmark.org/t/transclusion-or-including-sub-documents-for-reuse/270/13
  if (vscode.workspace.getConfiguration('markprint')['markdown-it-include']['enable']) {
    md.use(require("markdown-it-include"), {
      root: path.dirname(filename),
      includeRe: /:\[.+\]\((.+\..+)\)/i
    });
  }

  statusbarmessage.dispose();
  return md.render(matterParts.content);

  } catch (error) {
    statusbarmessage.dispose();
    showErrorMessage('convertMarkdownToHtml()', error);
  }
}

/*
 * https://github.com/microsoft/vscode/blob/ca4ceeb87d4ff935c52a7af0671ed9779657e7bd/extensions/markdown-language-features/src/slugify.ts#L26
 */
function Slug(string) {
  try {
    var stg = encodeURI(
      string.trim()
            .toLowerCase()
            .replace(/\s+/g, '-') // Replace whitespace with -
            .replace(/[\]\[\!\'\#\$\%\&\(\)\*\+\,\.\/\:\;\<\=\>\?\@\\\^\_\{\|\}\~\`。，、；：？！…—·ˉ¨‘’“”々～‖∶＂＇｀｜〃〔〕〈〉《》「」『』．〖〗【】（）［］｛｝]/g, '') // Remove known punctuators
            .replace(/^\-+/, '') // Remove leading -
            .replace(/\-+$/, '') // Remove trailing -
    );
    return stg;
  } catch (error) {
    showErrorMessage('Slug()', error);
  }
}

/*
 * make html
 */
function makeHtml(data, uri, options = {}) {
  try {
    // read styles
    var style = '';
    style += readStyles({
      uri,
      template: options.template,
      frontMatter: options.frontMatter
    });

    // get title
    var title = path.basename(uri.fsPath);

    // read template
    var filename = path.join(__dirname, 'template', 'template.html');
    var template = readFile(filename);

    // read mermaid javascripts
    var mermaidServer = vscode.workspace.getConfiguration('markprint')['mermaidServer'] || '';
    var mermaid = '<script src=\"' + mermaidServer + '\"></script>';

    // compile template
    var mustache = require('mustache');

    var view = {
      title: title,
      style: style,
      content: data,
      mermaid: mermaid
    };
    return mustache.render(template, view);
  } catch (error) {
    showErrorMessage('makeHtml()', error);
    throw error;
  }
}

/*
 * export a html to a html file
 */
function exportHtml(data, filename) {
  fs.writeFile(filename, data, 'utf-8', function (error) {
    if (error) {
      if (!error.__markprintLogged) {
        showErrorMessage('exportHtml()', error);
      }
      return;
    }
  });
}

/*
 * export a html to a pdf file (html-pdf)
 */
function exportPdf(data, filename, type, uri) {

  if (!INSTALL_CHECK) {
    return;
  }
  if (!checkPuppeteerBinary()) {
    showErrorMessage('Chromium or Chrome does not exist! \
      See https://github.com/gh4-io/MarkPrint#install');
    return;
  }

  var StatusbarMessageTimeout = vscode.workspace.getConfiguration('markprint')['StatusbarMessageTimeout'];
    vscode.window.setStatusBarMessage('');
    var exportFilename = getOutputDir(filename, uri);
    const documentLabelFromUri = uri && uri.fsPath ? path.basename(uri.fsPath) : null;
    const fallbackLabel = path.basename(filename);
    const documentLabel = documentLabelFromUri || fallbackLabel;
    const progressTitle = `[${EXTENSION_DISPLAY_NAME}] Exporting ${documentLabel} (${type.toUpperCase()})...`;

    return vscode.window.withProgress({
      location: vscode.ProgressLocation.Notification,
      title: progressTitle
    }, async () => {
      let tmpfilename = null;
      const debug = vscode.workspace.getConfiguration('markprint')['debug'] || false;
      try {
        // export html
        if (type == 'html') {
          exportHtml(data, exportFilename);
          vscode.window.setStatusBarMessage('$(markdown) ' + exportFilename, StatusbarMessageTimeout);
          return;
        }

        const puppeteer = require('puppeteer-core');
        // create temporary file
        var f = path.parse(filename);
        tmpfilename = path.join(f.dir, f.name + '_tmp.html');
        exportHtml(data, tmpfilename);
        const executablePathSetting = vscode.workspace.getConfiguration('markprint')['executablePath'] || '';
        const executablePath = resolveSettingPath(executablePathSetting, uri);
        var options = {
          executablePath: executablePath || puppeteer.executablePath(),
          args: ['--lang='+vscode.env.language, '--no-sandbox', '--disable-setuid-sandbox']
          // Setting Up Chrome Linux Sandbox
          // https://github.com/puppeteer/puppeteer/blob/master/docs/troubleshooting.md#setting-up-chrome-linux-sandbox
      };
        const browser = await puppeteer.launch(options);
        const page = await browser.newPage();
        await page.setDefaultTimeout(0);
        await page.goto(vscode.Uri.file(tmpfilename).toString(), { waitUntil: 'networkidle0' });
        // generate pdf
        // https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagepdfoptions
        if (type == 'pdf') {
          // If width or height option is set, it overrides the format option.
          // In order to set the default value of page size to A4, we changed it from the specification of puppeteer.
          var width_option = vscode.workspace.getConfiguration('markprint', uri)['width'] || '';
          var height_option = vscode.workspace.getConfiguration('markprint', uri)['height'] || '';
          var format_option = '';
          if (!width_option && !height_option) {
            format_option = vscode.workspace.getConfiguration('markprint', uri)['format'] || 'A4';
          }
          var landscape_option;
          if (vscode.workspace.getConfiguration('markprint', uri)['orientation'] == 'landscape') {
            landscape_option = true;
          } else {
            landscape_option = false;
          }
          var options = {
            path: exportFilename,
            scale: vscode.workspace.getConfiguration('markprint', uri)['scale'],
            displayHeaderFooter: vscode.workspace.getConfiguration('markprint', uri)['displayHeaderFooter'],
            headerTemplate: transformTemplate(vscode.workspace.getConfiguration('markprint', uri)['headerTemplate'] || ''),
            footerTemplate: transformTemplate(vscode.workspace.getConfiguration('markprint', uri)['footerTemplate'] || ''),
            printBackground: vscode.workspace.getConfiguration('markprint', uri)['printBackground'],
            landscape: landscape_option,
            pageRanges: vscode.workspace.getConfiguration('markprint', uri)['pageRanges'] || '',
            format: format_option,
            width: vscode.workspace.getConfiguration('markprint', uri)['width'] || '',
            height: vscode.workspace.getConfiguration('markprint', uri)['height'] || '',
            margin: {
              top: vscode.workspace.getConfiguration('markprint', uri)['margin']['top'] || '',
              right: vscode.workspace.getConfiguration('markprint', uri)['margin']['right'] || '',
              bottom: vscode.workspace.getConfiguration('markprint', uri)['margin']['bottom'] || '',
              left: vscode.workspace.getConfiguration('markprint', uri)['margin']['left'] || ''
            },
            timeout: 0
          };
          await page.pdf(options);
        }

        // generate png and jpeg
        // https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagescreenshotoptions
        if (type == 'png' || type == 'jpeg') {
          // Quality options do not apply to PNG images.
          var quality_option;
          if (type == 'png') {
            quality_option = undefined;
          }
          if (type == 'jpeg') {
            quality_option = vscode.workspace.getConfiguration('markprint')['quality'] || 100;
          }

          // screenshot size
          var clip_x_option = vscode.workspace.getConfiguration('markprint')['clip']['x'] || null;
          var clip_y_option = vscode.workspace.getConfiguration('markprint')['clip']['y'] || null;
          var clip_width_option = vscode.workspace.getConfiguration('markprint')['clip']['width'] || null;
          var clip_height_option = vscode.workspace.getConfiguration('markprint')['clip']['height'] || null;
          var options;
          if (clip_x_option !== null && clip_y_option !== null && clip_width_option !== null && clip_height_option !== null) {
            options = {
              path: exportFilename,
              quality: quality_option,
              fullPage: false,
              clip: {
                x: clip_x_option,
                y: clip_y_option,
                width: clip_width_option,
                height: clip_height_option,
              },
              omitBackground: vscode.workspace.getConfiguration('markprint')['omitBackground'],
            }
          } else {
            options = {
              path: exportFilename,
              quality: quality_option,
              fullPage: true,
              omitBackground: vscode.workspace.getConfiguration('markprint')['omitBackground'],
            }
          }
          await page.screenshot(options);
        }

        await browser.close();
        vscode.window.setStatusBarMessage('$(markdown) ' + exportFilename, StatusbarMessageTimeout);
      } catch (error) {
        if (!error || !error.__markprintLogged) {
          showErrorMessage('exportPdf()', error);
        } else {
          console.error('exportPdf()', error && error.message ? error.message : error);
        }
      } finally {
        if (!debug && tmpfilename && isExistsPath(tmpfilename)) {
          deleteFile(tmpfilename);
        }
      }
    } // async
  ); // vscode.window.withProgress
}

/**
 * Transform the text of the header or footer template, replacing the following supported placeholders:
 *
 * - `%%ISO-DATETIME%%` – For an ISO-based date and time format: `YYYY-MM-DD hh:mm:ss`
 * - `%%ISO-DATE%%` – For an ISO-based date format: `YYYY-MM-DD`
 * - `%%ISO-TIME%%` – For an ISO-based time format: `hh:mm:ss`
 */
function transformTemplate(templateText) {
  if (templateText.indexOf('%%ISO-DATETIME%%') !== -1) {
    templateText = templateText.replace('%%ISO-DATETIME%%', new Date().toISOString().substr(0, 19).replace('T', ' '));
  }
  if (templateText.indexOf('%%ISO-DATE%%') !== -1) {
    templateText = templateText.replace('%%ISO-DATE%%', new Date().toISOString().substr(0, 10));
  }
  if (templateText.indexOf('%%ISO-TIME%%') !== -1) {
    templateText = templateText.replace('%%ISO-TIME%%', new Date().toISOString().substr(11, 8));
  }

  return templateText;
}

function isExistsPath(path) {
  if (path.length === 0) {
    return false;
  }
  try {
    fs.accessSync(path);
    return true;
  } catch (error) {
    console.warn(error.message);
    return false;
  }
}

function isExistsDir(dirname) {
  if (dirname.length === 0) {
    return false;
  }
  try {
    if (fs.statSync(dirname).isDirectory()) {
      return true;
    } else {
      console.warn('Directory does not exist!') ;
      return false;
    }
  } catch (error) {
    console.warn(error.message);
    return false;
  }
}

function deleteFile (path) {
  var rimraf = require('rimraf')
  rimraf.sync(path);
}

function getOutputDir(filename, resource) {
  try {
    var outputDir;
    if (resource === undefined) {
      return filename;
    }
    var outputDirectorySetting = vscode.workspace.getConfiguration('markprint')['outputDirectory'] || '';
    var outputDirectory = resolveSettingPath(outputDirectorySetting, resource);
    if (outputDirectory.length === 0) {
      return filename;
    }

    // Use a home directory relative path If it starts with ~.
    if (outputDirectory.indexOf('~') === 0) {
      outputDir = outputDirectory.replace(/^~/, os.homedir());
      mkdir(outputDir);
      return path.join(outputDir, path.basename(filename));
    }

    // Use path if it is absolute
    if (path.isAbsolute(outputDirectory)) {
      if (!isExistsDir(outputDirectory)) {
        showErrorMessage(`The output directory specified by the markprint.outputDirectory option does not exist.\
          Check the markprint.outputDirectory option. ` + outputDirectory);
        return;
      }
      return path.join(outputDirectory, path.basename(filename));
    }

    // Use a workspace relative path if there is a workspace and markprint.outputDirectoryRootPath = workspace
    var outputDirectoryRelativePathFile = vscode.workspace.getConfiguration('markprint')['outputDirectoryRelativePathFile'];
    let root = vscode.workspace.getWorkspaceFolder(resource);
    if (outputDirectoryRelativePathFile === false && root) {
      outputDir = path.join(root.uri.fsPath, outputDirectory);
      mkdir(outputDir);
      return path.join(outputDir, path.basename(filename));
    }

    // Otherwise look relative to the markdown file
    outputDir = path.join(path.dirname(resource.fsPath), outputDirectory);
    mkdir(outputDir);
    return path.join(outputDir, path.basename(filename));
  } catch (error) {
    showErrorMessage('getOutputDir()', error);
  }
}

function mkdir(path) {
  if (isExistsDir(path)) {
    return;
  }
  var mkdirp = require('mkdirp');
  return mkdirp.sync(path);
}

function readFile(filename, encode) {
  if (filename.length === 0) {
    return '';
  }
  if (!encode && encode !== null) {
    encode = 'utf-8';
  }
  if (filename.indexOf('file://') === 0) {
    if (process.platform === 'win32') {
      filename = filename.replace(/^file:\/\/\//, '')
                 .replace(/^file:\/\//, '');
    } else {
      filename = filename.replace(/^file:\/\//, '');
    }
  }
  if (isExistsPath(filename)) {
    return fs.readFileSync(filename, encode);
  }

  throw new Error(`File not found: ${filename} (${path.isAbsolute(filename) ? 'absolute' : 'relative'})`);
}

function convertImgPath(src, filename) {
  try {
    var href = decodeURIComponent(src);
    href = href.replace(/("|')/g, '')
          .replace(/\\/g, '/')
          .replace(/#/g, '%23');
    var protocol = url.parse(href).protocol;
    if (protocol === 'file:' && href.indexOf('file:///') !==0) {
      return href.replace(/^file:\/\//, 'file:///');
    } else if (protocol === 'file:') {
      return href;
    } else if (!protocol || path.isAbsolute(href)) {
      href = path.resolve(path.dirname(filename), href).replace(/\\/g, '/')
                                                      .replace(/#/g, '%23');
      if (href.indexOf('//') === 0) {
        return 'file:' + href;
      } else if (href.indexOf('/') === 0) {
        return 'file://' + href;
      } else {
        return 'file:///' + href;
      }
    } else {
      return src;
    }
  } catch (error) {
    showErrorMessage('convertImgPath()', error);
  }
}

function makeCss(filename) {
  try {
    // Check cache first
    const cachedCss = cacheManager.getCSS(filename);
    if (cachedCss) {
      debugLogger.log('stylesheet', 'Using cached CSS', { path: filename });
      return '\n<style>\n' + cachedCss + '\n</style>\n';
    }

    var css = readFile(filename);
    if (css) {
      // Cache the CSS content
      cacheManager.setCSS(filename, css);
      return '\n<style>\n' + css + '\n</style>\n';
    } else {
      return '';
    }
  } catch (error) {
    showErrorMessage('makeCss()', error);
  }
}

function readStyles(options = {}) {
  try {
    const { uri, template, frontMatter } = options || {};
    let style = '';
    const appliedStyles = [];

    const includeDefaultInfo = debugLogger.describeSetting('markprint', 'includeDefaultStyles');
    const includeDefaultStyles = includeDefaultInfo.value;
    const highlightSettingInfo = debugLogger.describeSetting('markprint', 'highlight');
    const highlightStyleSettingInfo = debugLogger.describeSetting('markprint', 'highlightStyle');
    const markdownStylesInfo = debugLogger.describeSetting('markdown', 'styles');
    const markprintStylesSettingInfo = debugLogger.describeSetting('markprint', 'styles');

    const frontMatterEntries = resolveFrontMatterStyleEntries(frontMatter, uri);
    const templateEntries = resolveTemplateStyleEntries(template);
    const configuredEntries = resolveConfiguredStyleEntries(uri, includeDefaultStyles);
    let stage = 'defaults';

    if (frontMatterEntries.length > 0) {
      stage = 'frontMatter';
      style = applyStyleEntries(style, frontMatterEntries, appliedStyles, 'frontMatter');
    } else if (templateEntries.length > 0) {
      stage = 'template.resources.css';
      style = applyStyleEntries(style, templateEntries, appliedStyles, 'template.resources.css');
    } else if (configuredEntries.length > 0) {
      stage = 'settings';
      style = applyStyleEntries(style, configuredEntries, appliedStyles, 'settings');
    } else {
      stage = 'defaults';
      style += applyDefaultStyleStack({
        uri,
        includeDefaultStyles,
        appliedStyles,
        includeDefaultInfo,
        highlightSettingInfo,
        highlightStyleSettingInfo
      });
    }

    debugLogger.log('styles', 'Resolved stylesheet stack', {
      document: uri ? uri.fsPath : 'unknown',
      stage,
      includeDefaultStyles: includeDefaultInfo,
      frontMatterStyles: frontMatterEntries.map(entry => entry.original),
      templateCss: template && template.resources ? template.resources.css || [] : [],
      markdownStyles: markdownStylesInfo,
      highlight: highlightSettingInfo,
      highlightStyle: highlightStyleSettingInfo,
      markprintStyles: markprintStylesSettingInfo,
      appliedStyles
    });

    return style;
  } catch (error) {
    throw error;
  }
}

function resolveFrontMatterStyleEntries(frontMatter, uri) {
  if (!frontMatter) {
    return [];
  }
  const values = [];
  if (Array.isArray(frontMatter.styles)) {
    values.push(...frontMatter.styles);
  }
  if (frontMatter.style) {
    if (Array.isArray(frontMatter.style)) {
      values.push(...frontMatter.style);
    } else {
      values.push(frontMatter.style);
    }
  }
  return values
    .filter(Boolean)
    .map(value => {
      const href = fixHref(uri, value);
      return href ? { original: value, href } : null;
    })
    .filter(Boolean);
}

function resolveTemplateStyleEntries(template) {
  if (!template || !template.resources || !Array.isArray(template.resources.css)) {
    return [];
  }
  return template.resources.css
    .filter(Boolean)
    .map(value => {
      const resolved = resolveTemplateStyleHref(value, template);
      return resolved ? { original: value, href: resolved.href, resolvedPath: resolved.resolvedPath } : null;
    })
    .filter(Boolean);
}

function resolveConfiguredStyleEntries(uri, includeDefaultStyles) {
  const entries = [];
  if (includeDefaultStyles) {
    const markdownConfig = vscode.workspace.getConfiguration('markdown', uri || null);
    const markdownStyles = markdownConfig ? markdownConfig['styles'] : '';
    if (markdownStyles && Array.isArray(markdownStyles) && markdownStyles.length > 0) {
      for (let i = 0; i < markdownStyles.length; i++) {
        const expandedMarkdownStyle = resolveSettingPath(markdownStyles[i], uri);
        if (!expandedMarkdownStyle) {
          continue;
        }
        const href = fixHref(uri, expandedMarkdownStyle);
        if (!href) {
          continue;
        }
        entries.push({
          original: markdownStyles[i],
          href,
          resolvedPath: expandedMarkdownStyle,
          source: 'markdown.styles'
        });
      }
    }
  }

  const markprintConfig = vscode.workspace.getConfiguration('markprint');
  const markprintStyles = markprintConfig['styles'] || '';
  if (markprintStyles && Array.isArray(markprintStyles) && markprintStyles.length > 0) {
    for (let i = 0; i < markprintStyles.length; i++) {
      const expanded = resolveSettingPath(markprintStyles[i], uri) || markprintStyles[i];
      try {
        const resolvedStyle = resolveStylesheetHref(markprintStyles[i], expanded, uri);
        entries.push({
          original: markprintStyles[i],
          href: resolvedStyle.href,
          resolvedPath: resolvedStyle.resolvedPath || expanded,
          source: resolvedStyle.origin || 'markprint.styles'
        });
      } catch (error) {
        showErrorMessage('markprint.styles', error);
      }
    }
  }
  return entries;
}

function resolveTemplateStyleHref(value, template) {
  if (!value) {
    return null;
  }
  const extensionPathValue = process.env.MARKPRINT_EXTENSION_PATH || path.join(__dirname);
  let resolved = value;
  resolved = resolved.replace(/\$\{extensionPath\}/g, extensionPathValue);
  if (template && template._workspaceFolder) {
    resolved = resolved.replace(/\$\{workspaceFolder\}/g, template._workspaceFolder);
  }
  if (template && template._manifestDir) {
    resolved = resolved.replace(/\$\{manifestDir\}/g, template._manifestDir);
  }

  if (/^[a-zA-Z]+:\/\//.test(resolved) || resolved.startsWith('file://')) {
    return { href: resolved, resolvedPath: null };
  }

  if (!path.isAbsolute(resolved)) {
    const baseDir = (template && template._manifestDir) || (template && template._workspaceFolder) || process.cwd();
    resolved = path.resolve(baseDir, resolved);
  }

  return {
    href: vscode.Uri.file(resolved).toString(),
    resolvedPath: resolved
  };
}

function applyStyleEntries(style, entries, appliedStyles, label) {
  let buffer = style;
  for (const entry of entries) {
    const injection = buildStyleInjection(entry.href);
    buffer += injection.snippet;
    appliedStyles.push({
      type: label,
      original: entry.original,
      resolved: entry.href,
      mode: injection.mode,
      filePath: entry.resolvedPath || injection.filePath || null,
      source: entry.source || label
    });
  }
  return buffer;
}

function applyDefaultStyleStack({ uri, includeDefaultStyles, appliedStyles, includeDefaultInfo, highlightSettingInfo, highlightStyleSettingInfo }) {
  let buffer = '';
  let filename = '';

  if (includeDefaultStyles) {
    filename = path.join(__dirname, 'styles', 'markdown.css');
    buffer += makeCss(filename);
    appliedStyles.push({ type: 'vscode.markdown.css', path: filename, source: includeDefaultInfo.source });
  }

  if (includeDefaultStyles) {
    const markdownConfig = vscode.workspace.getConfiguration('markdown', uri || null);
    const styles = markdownConfig ? markdownConfig['styles'] : '';
    if (styles && Array.isArray(styles) && styles.length > 0) {
      for (let i = 0; i < styles.length; i++) {
        const expandedMarkdownStyle = resolveSettingPath(styles[i], uri);
        if (!expandedMarkdownStyle) {
          continue;
        }
        const href = fixHref(uri, expandedMarkdownStyle);
        const injection = buildStyleInjection(href);
        buffer += injection.snippet;
        appliedStyles.push({
          type: 'markdown.styles',
          original: styles[i],
          expanded: expandedMarkdownStyle,
          resolved: href,
          mode: injection.mode,
          filePath: injection.filePath || null
        });
      }
    }
  }

  const highlightStyle = highlightStyleSettingInfo.value || '';
  const isHighlightEnabled = highlightSettingInfo.value;
  if (isHighlightEnabled) {
    if (highlightStyle) {
      filename = path.join(__dirname, 'node_modules', 'highlight.js', 'styles', highlightStyle);
      buffer += makeCss(filename);
      appliedStyles.push({ type: 'highlight.js', path: filename, source: highlightStyleSettingInfo.source });
    } else {
      filename = path.join(__dirname, 'styles', 'tomorrow.css');
      buffer += makeCss(filename);
      appliedStyles.push({ type: 'highlight.js', path: filename, source: 'default' });
    }
  }

  if (includeDefaultStyles) {
    filename = path.join(__dirname, 'styles', 'markprint.css');
    buffer += makeCss(filename);
    appliedStyles.push({ type: 'markprint.default', path: filename, source: includeDefaultInfo.source });
  }

  return buffer;
}

function buildStyleInjection(href) {
  if (!href) {
    return { snippet: '', mode: 'skip' };
  }
  const inlineCandidate = tryInlineLocalStylesheet(href);
  if (inlineCandidate) {
    return { snippet: inlineCandidate.css, mode: 'inline', filePath: inlineCandidate.filePath };
  }
  return { snippet: '<link rel=\"stylesheet\" href=\"' + href + '\" type=\"text/css\">', mode: 'link' };
}

function tryInlineLocalStylesheet(href) {
  try {
    const parsed = vscode.Uri.parse(href);
    if (parsed.scheme && parsed.scheme !== 'file') {
      return null;
    }
    const filePath = parsed.scheme === 'file' ? parsed.fsPath : href;
    const css = makeCss(filePath);
    if (css && css.length > 0) {
      return { css, filePath };
    }
  } catch (error) {
    console.warn('Failed to inline stylesheet:', error.message);
  }
  return null;
}

/*
 * vscode/extensions/markdown-language-features/src/features/previewContentProvider.ts fixHref()
 * https://github.com/Microsoft/vscode/blob/0c47c04e85bc604288a288422f0a7db69302a323/extensions/markdown-language-features/src/features/previewContentProvider.ts#L95
 *
 * Extension Authoring: Adopting Multi Root Workspace APIs ?E Microsoft/vscode Wiki
 * https://github.com/Microsoft/vscode/wiki/Extension-Authoring:-Adopting-Multi-Root-Workspace-APIs
 */
function fixHref(resource, href) {
  try {
    if (!href) {
      return href;
    }

    // Use href if it is already an URL
    const hrefUri = vscode.Uri.parse(href);
    if (['http', 'https'].indexOf(hrefUri.scheme) >= 0) {
      return hrefUri.toString();
    }

    // Use a home directory relative path If it starts with ^.
    if (href.indexOf('~') === 0) {
      return vscode.Uri.file(href.replace(/^~/, os.homedir())).toString();
    }

    // Use href as file URI if it is absolute
    if (path.isAbsolute(href)) {
      return vscode.Uri.file(href).toString();
    }

    // Use a workspace relative path if there is a workspace and markprint.stylesRelativePathFile is false
    var stylesRelativePathFile = vscode.workspace.getConfiguration('markprint')['stylesRelativePathFile'];
    let root = vscode.workspace.getWorkspaceFolder(resource);
    if (stylesRelativePathFile === false && root) {
      return vscode.Uri.file(path.join(root.uri.fsPath, href)).toString();
    }

    // Otherwise look relative to the markdown file
    return vscode.Uri.file(path.join(path.dirname(resource.fsPath), href)).toString();
  } catch (error) {
    showErrorMessage('fixHref()', error);
  }
}

function checkPuppeteerBinary() {
  try {
    // settings.json
    var executablePathSetting = vscode.workspace.getConfiguration('markprint')['executablePath'] || '';
    var executablePath = resolveSettingPath(executablePathSetting);
    if (isExistsPath(executablePath)) {
      INSTALL_CHECK = true;
      return true;
    }

    // bundled Chromium
    const puppeteer = require('puppeteer-core');
    executablePath = puppeteer.executablePath();
    if (isExistsPath(executablePath)) {
      return true;
    } else {
      return false;
    }
  } catch (error) {
    showErrorMessage('checkPuppeteerBinary()', error);
  }
}

/*
 * puppeteer install.js
 * https://github.com/GoogleChrome/puppeteer/blob/master/install.js
 */
function installChromium() {
  try {
    vscode.window.showInformationMessage(`[${EXTENSION_DISPLAY_NAME}] Installing Chromium ...`);
    var statusbarmessage = vscode.window.setStatusBarMessage('$(markdown) Installing Chromium ...');

    // proxy setting
    setProxy();

    var StatusbarMessageTimeout = vscode.workspace.getConfiguration('markprint')['StatusbarMessageTimeout'];
    const puppeteer = require('puppeteer-core');
    const browserFetcher = puppeteer.createBrowserFetcher();
    const revision = require(path.join(__dirname, 'node_modules', 'puppeteer-core', 'package.json')).puppeteer.chromium_revision;
    const revisionInfo = browserFetcher.revisionInfo(revision);

    // download Chromium
    browserFetcher.download(revisionInfo.revision, onProgress)
      .then(() => browserFetcher.localRevisions())
      .then(onSuccess)
      .catch(onError);

    function onSuccess(localRevisions) {
      console.log('Chromium downloaded to ' + revisionInfo.folderPath);
      localRevisions = localRevisions.filter(revision => revision !== revisionInfo.revision);
      // Remove previous chromium revisions.
      const cleanupOldVersions = localRevisions.map(revision => browserFetcher.remove(revision));

      if (checkPuppeteerBinary()) {
        INSTALL_CHECK = true;
        statusbarmessage.dispose();
        vscode.window.setStatusBarMessage('$(markdown) Chromium installation succeeded!', StatusbarMessageTimeout);
        vscode.window.showInformationMessage(`[${EXTENSION_DISPLAY_NAME}] Chromium installation succeeded.`);
        return Promise.all(cleanupOldVersions);
      }
    }

    function onError(error) {
      statusbarmessage.dispose();
      vscode.window.setStatusBarMessage('$(markdown) ERROR: Failed to download Chromium!', StatusbarMessageTimeout);
      showErrorMessage('Failed to download Chromium! \
        If you are behind a proxy, set the http.proxy option to settings.json and restart Visual Studio Code. \
        See https://github.com/gh4-io/MarkPrint#install', error);
    }

    function onProgress(downloadedBytes, totalBytes) {
      var progress = parseInt(downloadedBytes / totalBytes * 100);
      vscode.window.setStatusBarMessage('$(markdown) Installing Chromium ' + progress + '%' , StatusbarMessageTimeout);
    }
  } catch (error) {
    showErrorMessage('installChromium()', error);
  }
}

function showErrorMessage(msg, error) {
  const detail = error
    ? (error instanceof Error ? (error.message || error.toString()) : String(error))
    : '';
  const combined = detail ? `${msg} - ${detail}` : msg;
  const formatted = `ERROR: ${combined}`;

  vscode.window.showErrorMessage(formatted);
  if (error && error.stack) {
    console.error(formatted);
    console.error(error.stack);
  } else {
    console.error(formatted);
  }
  if (error && typeof error === 'object') {
    error.__markprintLogged = true;
  }
}

function setProxy() {
  var https_proxy = vscode.workspace.getConfiguration('http')['proxy'] || '';
  if (https_proxy) {
    process.env.HTTPS_PROXY = https_proxy;
    process.env.HTTP_PROXY = https_proxy;
  }
}

function setBooleanValue(a, b) {
  if (a === false) {
    return false
  } else {
    return a || b
  }
}

function init() {
  try {
    if (checkPuppeteerBinary()) {
      INSTALL_CHECK = true;
    } else {
      installChromium();
    }
  } catch (error) {
    showErrorMessage('init()', error);
  }
}

function describeFallbackReason(reason, extra = {}, fallbackTemplate) {
  if (reason === 'unresolvedFrontMatter') {
    if (extra.requested) {
      const fieldLabel = extra.field ? `${extra.field} ` : '';
      return `Requested ${fieldLabel}"${extra.requested}" could not be resolved. Select a profile to continue.`;
    }
    return 'Front matter is missing a pipeline_profile. Select the profile to use.';
  }
  if (reason === 'invalidWorkspaceState' && extra.lastTemplateId) {
    return `Last used profile "${extra.lastTemplateId}" is unavailable. Pick another profile to continue.`;
  }
  if (reason === 'missingTemplate' && fallbackTemplate) {
    return `No profile specified. ${fallbackTemplate.label} is the default, but you can pick another.`;
  }
  return 'Select a pipeline profile to continue.';
}

async function handleTemplateFallback({ document, reason, extra, fallbackTemplate, workspaceState }) {
  const message = describeFallbackReason(reason, extra, fallbackTemplate);
  if (statusBarManager) {
    statusBarManager.showTemplateWarning(message);
  }
  try {
    if (!templateRegistry) {
      return fallbackTemplate;
    }
    const templates = templateRegistry.getAllTemplates();
    if (templates.length === 0) {
      vscode.window.showWarningMessage('No pipeline profiles are available. Please create or load one before exporting.');
      return null;
    }
    const sorted = templates
      .slice()
      .sort((a, b) => a.label.localeCompare(b.label));
    if (fallbackTemplate && !sorted.find(t => t.id === fallbackTemplate.id)) {
      sorted.unshift(fallbackTemplate);
    }
    const items = sorted.map(t => ({
      label: t.label,
      description: `v${t.version} • ${t._source || 'bundled'}`,
      detail: t.description || t.id,
      picked: fallbackTemplate ? t.id === fallbackTemplate.id : false,
      template: t
    }));

    const selected = await vscode.window.showQuickPick(items, {
      placeHolder: message || 'Select a pipeline profile',
      title: `${EXTENSION_DISPLAY_NAME}: Select pipeline profile`,
      ignoreFocusOut: true
    });

    if (!selected) {
      return null;
    }

    const state = workspaceState || (extensionContext && extensionContext.workspaceState);
    if (state) {
      await state.update(`markprint.lastTemplate.${document.uri.fsPath}`, selected.template.id);
    }

    return selected.template;
  } finally {
    if (statusBarManager) {
      statusBarManager.clearTemplateWarning();
    }
  }
}
